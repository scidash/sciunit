"""SciUnit: A Test-Driven Framework for Validation of 
     Quantitative Scientific Models"""

from collections import Callable

class Error(Exception):
  """Base class for errors in sciunit's core."""

#
# Test
#
class Test(object):
  """Abstract base class for tests."""
  def __init__(self, observation, name=None, **params):
      if name is None:
        name = self.__class__.__name__
      self.name = name
      
      if self.description is None:
        self.description = self.__class__.__doc__
      
      self.params = params

      self.observation = observation
      self.validate_observation(observation)

      if not issubclass(self.score_type, Score):
        raise Error("Test %s does not specify a score type." % self.name)

  name = None
  """The name of the test. Defaults to the test class name."""

  description = None
  """A description of the test. Defaults to the docstring for the class."""

  observation = None
  """The empirical observation that the test is using."""

  params = None
  """A dictionary containing the parameters to the test."""

  def validate_observation(self, observation):
    """(Optional) Implement to validate the observation provided to the 
    constructor.

    Raises an ObservationError if invalid."""
    return True
  
  required_capabilities = ()
  """A sequence of capabilities that a model must have in order for the 
  test to be run. Defaults to empty."""

  def generate_prediction(self, model):
    """Generates a prediction from a model using the required capabilities.

    No default implementation."""
    raise NotImplementedError("Test %s does not implement generate_prediction."
       % self.name)

  score_type = None

  def score_prediction(self, observation, prediction):
    """Generates a score given the observations provided in the constructor
    and the prediction generated by generate_prediction.

    Must generate a score of score_type.

    No default implementation."""
    raise NotImplementedError("Test %s does not implement score_prediction."
      % self.name)

  def judge(self, model):
    """Generates a score for the provided model.

    Operates as follows:
    1. Checks if the model has all the required capabilities.
    2. Calls generate_prediction to generate a prediction.
    3. Calls score_prediction to generate a score.
    4. Checks that the score is of score_type, raising an InvalidScoreError.
    5. Equips the score with metadata:
       a) A reference to the model, in attribute model.
       b) A reference to the test, in attribute test.
       c) A reference to the prediction, in attribute prediction.
       d) A reference to the observation, in attribute observation.
    6. Returns the score.
    """
    # 1.
    check_capabilities(self, model)
    # 2.
    prediction = self.generate_prediction(model)
    # 3.
    observation = self.observation
    score = self.score_prediction(observation, prediction)
    # 4.
    if not isinstance(score, self.score_type):
      raise InvalidScoreError("Score for test %s is not of correct type.")
    # 5.
    score.model = model
    score.test = self
    score.prediction = prediction
    score.observation = observation
    return score

class ObservationError(Error):
  """Raised when an observation passed to a test is invalid."""

#
# Test Suites
#

class TestSuite(object):
  """A collection of tests."""

  def __init__(self, tests, name=None):
    # turn singleton test into a sequence
    if isinstance(tests, Test):
      tests = (tests,)
    else:
      for test in tests:
        assert isinstance(test, Test)
    self.tests = tests

    if name is None:
      name = self.__class__.__name__
    self.name = name

  name = None
  """The name of the test suite. Defaults to the class name."""

  description = None
  """The description of the test suite. No default."""

  tests = None
  """The sequence of tests that this suite contains."""

  def judge(self,models,summarize=True):
    """Judges the provided models against each test in the test suite.

    Returns a ScoreMatrix.
    """
    if isinstance(models, Model):
      models = (models,)
    matrix = ScoreMatrix(self.tests, models)
    for test in self.tests:
      for model in models:
        matrix[test, model] = test.judge(model)
    return matrix

#
# Scores
#

class Score(object):
  """Abstract base class for scores.
  Pairs a score value with the test and model that produced it."""
  
  def __init__(self, score, related_data={}):
    self.score, self.related_data = score, related_data
  
  score = None
  """The score itself."""

  related_data = {}
  """Data specific to the result of a test run on a model."""

  test = None
  """The test taken. Set automatically by Test.judge."""

  model = None
  """The model judged. Set automatically by Test.judge."""

  normalized = False
  """Specifies whether the score is normalized or not."""

  sort_key = None
  """A floating point version of the score used for sorting. 

  If normalized = True, this must be in the range 0.0 to 1.0 
  (used for coloring table cells)."""

  @property
  def summary(self):
    """Summarize the performance of a model on a test."""
    return "===Model '%s' achieved score %s on test '%s'.===" % 
                                    (self.model.name,
                                     self.__str__(),
                                     self.test.name)

  def summarize(self):
    print self.summary

  def __str__(self):
    return u'%s' % self.score

class InvalidScoreError(Exception):
  """Error raised when a score is invalid."""

class ScoreMatrix(object):
  """Represents a matrix of scores derived from a test suite.

  Can use like this:

    >>> sm[test]
    { model_1: Score_1, ... model_n: score_n }
    >>> sm[model]
    { test_1: Score_1, ..., test_n: score_n }
    >>> sm[test, model]
    score
    >>> sm[test, model] = score
  """
  def __init__(self, tests, models):
    self.tests = tests
    self.models = models

    self._matrix = matrix = { }
    for test in tests:
      column = matrix[test] = { }
      for model in models:
        column[model] = None

  def __getitem__(self, key):
    if isinstance(key, Test):
      return self._matrix[key]
    elif isinstance(key, Model):
      r = { }
      matrix = self._matrix
      for test in self.tests:
        r[test] = matrix[test][model]
      return r
    else:
      (test, model) = key
      return self._matrix[test][model]

  def __setitem__(self, key):
    (test, model) = key
    if isinstance(test, Test) and isinstance(model, Model):
      return self._matrix[test][model]
    else:
      raise Error("Invalid index, expected (test, model).")

#
# Models
#

class Model(object):
  """Abstract base class for sciunit models."""
  def __init__(self, name=None):
    if name is None:
      name = self.__class__.__name__
    self.name = name

  name = None
  """The name of the model. Defaults to the class name."""

#
# Capabilities
#

class Capability(object):
  """Abstract base class for sciunit capabilities."""
  def __init__(self, name=None):
    if name is None:
      name = self.__class__.__name__
    self.name = name

  name = None
  """The name of the capability. Defaults to the class name."""

  @classmethod
  def check(cls, model):
    """Checks whether the provided model has this capability.

    By default, uses isinstance.
    """
    return isinstance(model, cls)

class CapabilityError(Exception):
  """Error raised when a required capability is not 
  provided by a model."""
  def __init__(self, model, capability):
    self.model = model
    self.capability = capability

    super(CapabilityError,self).__init__(\
      "Model %s does not provide required capability: %s" % \
      (model.name,capability().name))
  
  model = None
  """The model that does not have the capability."""

  capability = None
  """The capability that is not provided."""

def check_capabilities(test, model):
  """Checks that the capabilities required by `test` are 
  implemented by `model`.

  First checks that `test` is a `Test` and `model` is a `Model`.
  """
  assert isinstance(test, Test)
  assert isinstance(model, Model)

  for c in test.required_capabilities:
    if not c.check(model):
      raise CapabilityError(model, c)

  return True
