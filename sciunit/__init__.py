"""SciUnit: A Test-Driven Framework for Validation of 
     Quantitative Scientific Models"""
import string
from collections import Callable
from IPython.display import HTML # TODO: make this optional

class Error(Exception):
  """Base class for errors in sciunit's core."""

#
# Test
#
class Test(object):
  """Abstract base class for tests."""
  def __init__(self, observation, name=None, **params):
      if name is None:
        name = self.__class__.__name__
      self.name = name
      
      if self.description is None:
        self.description = self.__class__.__doc__
      
      self.params = params

      self.observation = observation
      self.validate_observation(observation)

      if not issubclass(self.score_type, Score):
        raise Error("Test %s does not specify a score type." % self.name)

  name = None
  """The name of the test. Defaults to the test class name."""

  description = None
  """A description of the test. Defaults to the docstring for the class."""

  observation = None
  """The empirical observation that the test is using."""

  params = None
  """A dictionary containing the parameters to the test."""

  def validate_observation(self, observation):
    """(Optional) Implement to validate the observation provided to the 
    constructor.

    Raises an ObservationError if invalid."""
    return True
  
  required_capabilities = ()
  """A sequence of capabilities that a model must have in order for the 
  test to be run. Defaults to empty."""

  def generate_prediction(self, model):
    """Generates a prediction from a model using the required capabilities.

    No default implementation."""
    raise NotImplementedError("Test %s does not implement generate_prediction."
       % self.name)

  score_type = None

  def score_prediction(self, observation, prediction):
    """Generates a score given the observations provided in the constructor
    and the prediction generated by generate_prediction.

    Must generate a score of score_type.

    No default implementation."""
    raise NotImplementedError("Test %s does not implement score_prediction."
      % self.name)

  def judge(self, model):
    """Generates a score for the provided model.

    Operates as follows:
    1. Checks if the model has all the required capabilities.
    2. Calls generate_prediction to generate a prediction.
    3. Calls score_prediction to generate a score.
    4. Checks that the score is of score_type, raising an InvalidScoreError.
    5. Equips the score with metadata:
       a) A reference to the model, in attribute model.
       b) A reference to the test, in attribute test.
       c) A reference to the prediction, in attribute prediction.
       d) A reference to the observation, in attribute observation.
    6. Returns the score.
    """
    # 1.
    check_capabilities(self, model)
    # 2.
    prediction = self.generate_prediction(model)
    # 3.
    observation = self.observation
    score = self.score_prediction(observation, prediction)
    # 4.
    if not isinstance(score, self.score_type):
      raise InvalidScoreError(
        ("Score for test %s is not of correct type.\n" % str(self)) +
        "Expected: %s" % str(self.score_type) + 
        "Got: %s" % str(type(score)))

    # 5.
    score.model = model
    score.test = self
    score.prediction = prediction
    score.observation = observation
    return score

  def __str__(self):
    if self.params:
      x = "%s, %s" % (str(self.observation), str(self.params))
    else:
      x = str(self.observation)
    return "%s(%s)" % (self.name, x)

  def __repr__(self):
    return str(self)

class ObservationError(Error):
  """Raised when an observation passed to a test is invalid."""

#
# Test Suites
#

class TestSuite(object):
  """A collection of tests."""

  def __init__(self, tests, name=None):
    # turn singleton test into a sequence
    if isinstance(tests, Test):
      tests = (tests,)
    else:
      for test in tests:
        assert isinstance(test, Test)
    self.tests = tests

    if name is None:
      name = self.__class__.__name__
    self.name = name

  name = None
  """The name of the test suite. Defaults to the class name."""

  description = None
  """The description of the test suite. No default."""

  tests = None
  """The sequence of tests that this suite contains."""

  def judge(self,models):
    """Judges the provided models against each test in the test suite.

    Returns a ScoreMatrix.
    """
    if isinstance(models, Model):
      models = (models,)
    matrix = ScoreMatrix(self.tests, models)
    for test in self.tests:
      for model in models:
        matrix[test, model] = test.judge(model)
    return matrix

#
# Scores
#

class Score(object):
  """Abstract base class for scores.

  Pairs a score value with the test and model that produced it."""
  
  def __init__(self, score, related_data={}):
    self.score, self.related_data = score, related_data
  
  score = None
  """The score itself."""

  related_data = {}
  """Data specific to the result of a test run on a model."""

  test = None
  """The test taken. Set automatically by Test.judge."""

  model = None
  """The model judged. Set automatically by Test.judge."""

  normalized = False
  """Specifies whether the score is normalized or not."""

  sort_key = None
  """A floating point version of the score used for sorting. 

  If normalized = True, this must be in the range 0.0 to 1.0 
  (used for coloring table cells)."""

  @property
  def summary(self):
    """Summarize the performance of a model on a test."""
    return "Model '%s' achieved score %s on test '%s'." % (self.model.name,
                              self.__str__(),
                              self.test.name)

  def summarize(self):
    print self.summary

  def __str__(self):
    return '%s(%s)' % (self.__class__.__name__, self.score)

  def __repr__(self):
    return str(self)

class InvalidScoreError(Exception):
  """Error raised when a score is invalid."""

class ScoreMatrix(object):
  """Represents a matrix of scores derived from a test suite.

  Can use like this:

    >>> sm[test]
    { model_1: Score_1, ... model_n: score_n }
    >>> sm[model]
    { test_1: Score_1, ..., test_n: score_n }
    >>> sm[test, model]
    score
    >>> sm[test, model] = score
  """
  def __init__(self, tests, models):
    self.tests = tests
    self.models = models

    self._matrix = matrix = { }
    for test in tests:
      column = matrix[test] = { }
      for model in models:
        column[model] = None

  def __getitem__(self, key):
    if isinstance(key, Test):
      return self._matrix[key]
    elif isinstance(key, Model):
      r = { }
      matrix = self._matrix
      for test in self.tests:
        r[test] = matrix[test][key]
      return r
    else:
      (test, model) = key
      return self._matrix[test][model]

  def __setitem__(self, key, value):
    (test, model) = key
    if isinstance(test, Test) and isinstance(model, Model):
      self._matrix[test][model] = value
    else:
      raise Error("Invalid index, expected (test, model).")

  def view(self):
    """Generates an HTML view suitable for display in the IPython notebook."""
    scripts = self._view_scripts()
    header = self._view_header()
    body = self._view_body()
    table = "<table>{header}{body}</table>".format(header=header, body=body)
    return HTML(table)

  def _view_scripts(self):
    return ""
    #return '''
    #<script type="text/javascript" src="/path/to/jquery-latest.js"></script> 
    #<script type="text/javascript" src="/path/to/jquery.tablesorter.js"></script> 
    #'''

  def _view_header(self):
    columns = string.join(
      "<th>%s</th>" % str(test)
      for test in self.tests
    )
    return "<thead><tr><th></th>{columns}</tr></thead>".format(columns=columns)

  def _view_body(self):
    rows = string.join(
      "<tr><td>{model}</td>{scores}</tr>".format(
        model=str(model), 
        scores=self._view_row(model))
      for model in self.models
    )
    return "<tbody>{rows}</tbody>".format(rows=rows)

  def _view_row(self, model):
    return string.join(
      "<td>{score}</td>".format(score=str(score))
      for score in self[model].itervalues())

#
# Models
#

class Model(object):
  """Abstract base class for sciunit models."""
  def __init__(self, name=None, **params):
    if name is None:
      name = self.__class__.__name__
    self.name = name

    self.params = params

  name = None
  """The name of the model. Defaults to the class name."""

  params = None
  """The parameters to the model (a dictionary)."""

  def __str__(self):
    return "%s(%s)" % (self.name, str(self.params))

  def __repr__(self):
    return str(self)
#
# Capabilities
#

class Capability(object):
  """Abstract base class for sciunit capabilities."""
  def __init__(self, name=None):
    if name is None:
      name = self.__class__.__name__
    self.name = name

  name = None
  """The name of the capability. Defaults to the class name."""

  @classmethod
  def check(cls, model):
    """Checks whether the provided model has this capability.

    By default, uses isinstance.
    """
    return isinstance(model, cls)

class CapabilityError(Exception):
  """Error raised when a required capability is not 
  provided by a model."""
  def __init__(self, model, capability):
    self.model = model
    self.capability = capability

    super(CapabilityError,self).__init__(\
      "Model %s does not provide required capability: %s" % \
      (model.name,capability().name))
  
  model = None
  """The model that does not have the capability."""

  capability = None
  """The capability that is not provided."""

def check_capabilities(test, model):
  """Checks that the capabilities required by `test` are 
  implemented by `model`.

  First checks that `test` is a `Test` and `model` is a `Model`.
  """
  assert isinstance(test, Test)
  assert isinstance(model, Model)

  for c in test.required_capabilities:
    if not c.check(model):
      raise CapabilityError(model, c)

  return True
